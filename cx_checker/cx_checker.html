<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type"/>
  </head>
  <body>
	<p>The game is authoritative, this tool may report failures that don't exist (and pass some that shouldn't!)</p>
    <input type="checkbox" id="random_runner" value="disabled" disabled> 
	<label for="random_runner"> Run random tests</label>
	<pre id="random_counter"></pre>
	<label for="solution">Choose TransmutationCX solution:</label>

	<input type="file"
		   id="solution-selector" name="solution"
		   accept=".solution">
	<pre id="square"></pre>
	<pre id="text_out"></pre>
    <!-- Include the JS generated by `wasm-pack build` -->
    <script src='omclone_cxchecker.js'></script>

    <script>
		// Like with the `--target web` output the exports are immediately
		// available but they won't work until we initialize the module. Unlike
		// `--target web`, however, the globals are all stored on a
		// `wasm_bindgen` global. The global itself is the initialization
		// function and then the properties of the global are all the exported
		// functions.
		//
		// Note that the name `wasm_bindgen` can be configured with the
		// `--no-modules-global` CLI flag
		const square_loc = document.getElementById("square");
		const text_loc = document.getElementById("text_out");
		const random_counter = document.getElementById("random_counter");
		const random_runner_input = document.getElementById("random_runner");
		random_runner_input.disabled = true;
		var filedata = null;
		var square_count = 0;
		var random_runs = 0;
		function add_square(white){
			square_count += 1;
			if (white){
				square_loc.textContent += "O";
			} else {
				square_loc.textContent += "X";
			}
			if (square_count == 8){
				square_loc.textContent += "\n";
				square_count = 0;
			}
		}
		function add_text(str){
			text_loc.textContent += str+"\n";
		}
		
		const { evaluate_solution, random_test } = wasm_bindgen;

		async function run() {
			await wasm_bindgen('omclone_cxchecker_bg.wasm');
		}

		const input = document.getElementById('solution-selector');
		//https://dilshankelsen.com/convert-file-to-byte-array/
		async function getAsByteArray(file) {
		  return new Uint8Array(await readFile(file))
		}
		function readFile(file) {
		  return new Promise((resolve, reject) => {
			// Create file reader
			let reader = new FileReader()

			// Register event listeners
			reader.addEventListener("loadend", e => resolve(e.target.result))
			reader.addEventListener("error", reject)

			// Read file
			reader.readAsArrayBuffer(file)
		  })
		}
		
		async function cxCheck(){
			const filename = input.files[0];
			filedata = await getAsByteArray(filename);
			text_loc.textContent = "";
			square_loc.textContent = "";
			random_counter.textContent = "";
			square_count = 0;
			random_runs = 0;
			evaluate_solution(filedata);
			random_runner_input.disabled = false;
		}
		function tryRunRandom(){
			let array = []
			array.push(getRandomInt(64))
			array.push(getRandomInt(64))
			array.push(getRandomInt(64))
			array.push(getRandomInt(64))
			array.push(getRandomInt(64))
			array.push(getRandomInt(64))
			if (random_test(filedata, array)){
				random_runs += 1
				random_counter.textContent = "random runs: "+random_runs+"\n";
				if (random_runner_input.checked){
					setTimeout(tryRunRandom, 10);
				}
			} else {
				random_runner_input.checked = false
				random_counter.textContent = "random runs: Crashed after "+random_runs+"\n";
			}
		}
		function getRandomInt(max) {
			return Math.floor(Math.random() * max);
		}

		function randomRunnerSetup(){
			if (random_runner_input.checked){
				setTimeout(tryRunRandom, 10);
			}
		}
		input.addEventListener('change', cxCheck);
		random_runner_input.addEventListener('change', randomRunnerSetup);
		
      run();
    </script>


    </script>
  </body>
</html>

